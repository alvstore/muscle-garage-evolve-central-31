
import { useState } from 'react';
import { hikvisionService } from '@/services/classes/integrations/hikvisionService';
import { useHikvisionSettings } from '@/hooks/access/use-hikvision-settings';
import { supabase } from '@/integrations/supabase/client';
import { toast } from 'sonner';
import type { HikvisionPerson } from '@/types/settings/hikvision-types';

export const useMemberAccess = () => {
  const [isProcessing, setIsProcessing] = useState(false);

  const getMemberCredential = async (memberId: string) => {
    try {
      const { data } = await supabase
        .from('hikvision_persons')
        .select('*')
        .eq('member_id', memberId)
        .single();
      
      return data;
    } catch (error) {
      console.error('Error fetching member credential:', error);
      return null;
    }
  };

  const registerMember = async (member: any, branchId: string, picture?: string): Promise<boolean> => {
    if (!branchId) {
      toast.error('Branch ID is required for member registration');
      return false;
    }

    setIsProcessing(true);
    try {
      // Check if member already has a Hikvision personId
      const credential = await getMemberCredential(member.id);
      
      if (credential?.person_id) {
        // Update existing person
        console.log('Updating existing Hikvision person:', credential.person_id);
        
        const person: HikvisionPerson = {
          personId: credential.person_id,
          memberId: member.id,
          name: `${member.first_name} ${member.last_name}`.trim(),
          cardNo: member.member_id || '',
          phone: member.phone,
          email: member.email,
          gender: member.gender?.toLowerCase(),
          status: 'active',
          faceData: picture ? [picture] : credential.face_data || [],
          branchId: branchId
        };

        // Update person in Hikvision via proxy
        const { data: updateResponse, error: updateError } = await supabase.functions.invoke('hikvision-proxy', {
          body: {
            branchId,
            endpoint: '/api/hpcgw/v1/person/update',
            method: 'POST',
            data: {
              personId: person.personId,
              name: person.name,
              gender: person.gender,
              cardNo: person.cardNo,
              phone: person.phone,
              email: person.email,
              pictures: person.faceData || []
            }
          }
        });

        if (updateError || !updateResponse?.success) {
          throw new Error(updateResponse?.error || 'Failed to update person in Hikvision');
        }

        // Update database record
        await supabase
          .from('hikvision_persons')
          .update({
            name: person.name,
            gender: person.gender,
            card_no: person.cardNo,
            phone: person.phone,
            email: person.email,
            face_data: person.faceData,
            sync_status: 'success',
            last_sync: new Date().toISOString(),
            updated_at: new Date().toISOString()
          })
          .eq('person_id', person.personId);

        toast.success('Member information updated in access control system');
        return true;
      }

      // Create new person in Hikvision
      const person: HikvisionPerson = {
        personId: '', // Will be generated by Hikvision
        memberId: member.id,
        name: `${member.first_name} ${member.last_name}`.trim(),
        cardNo: member.member_id || '',
        phone: member.phone,
        email: member.email,
        gender: member.gender?.toLowerCase(),
        status: 'active',
        faceData: picture ? [picture] : [],
        branchId: branchId
      };

      // Register the member in Hikvision
      const result = await hikvisionService.registerMember(person, branchId);
      if (!result.success) {
        throw new Error(result.error);
      }

      // Configure default access (if devices exist)
      const { data: devices } = await supabase
        .from('hikvision_devices')
        .select('device_id')
        .eq('branch_id', branchId)
        .eq('status', 'active')
        .limit(1);

      if (devices && devices.length > 0) {
        const deviceSerialNo = devices[0].device_id;
        const validStartTime = new Date().toISOString();
        const validEndTime = new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toISOString(); // 1 year from now

        await hikvisionService.configureAccess(
          result.data.personId,
          deviceSerialNo,
          [1], // Default door
          validStartTime,
          validEndTime,
          branchId
        );
      }
      
      toast.success('Member registered with access control system');
      return true;
    } catch (error) {
      console.error('Error registering member with Hikvision:', error);
      toast.error('Failed to register member with access control system');
      return false;
    } finally {
      setIsProcessing(false);
    }
  };

  const unregisterMember = async (memberId: string, branchId: string): Promise<boolean> => {
    setIsProcessing(true);
    try {
      const credential = await getMemberCredential(memberId);
      if (!credential) return true; // Already not registered

      // Update person status to inactive via proxy
      const { data: deleteResponse, error: deleteError } = await supabase.functions.invoke('hikvision-proxy', {
        body: {
          branchId,
          endpoint: '/api/hpcgw/v1/person/delete',
          method: 'POST',
          data: { personId: credential.person_id }
        }
      });

      if (deleteError || !deleteResponse?.success) {
        console.warn('Failed to delete person from Hikvision:', deleteResponse?.error);
      }

      // Update local database
      await supabase
        .from('hikvision_persons')
        .update({ 
          status: 'inactive',
          sync_status: 'success',
          updated_at: new Date().toISOString()
        })
        .eq('member_id', memberId);

      // Remove access privileges
      await supabase
        .from('hikvision_access_privileges')
        .update({ 
          status: 'inactive',
          updated_at: new Date().toISOString()
        })
        .eq('person_id', credential.person_id);

      toast.success('Member access revoked successfully');
      return true;
    } catch (error) {
      console.error('Error unregistering member from Hikvision:', error);
      toast.error('Failed to revoke access credentials');
      return false;
    } finally {
      setIsProcessing(false);
    }
  };

  const grantAccess = async (
    memberId: string,
    branchId: string,
    deviceSerialNo: string, 
    doorList: number[],
    validStartTime: string,
    validEndTime: string
  ): Promise<boolean> => {
    setIsProcessing(true);
    try {
      const credential = await getMemberCredential(memberId);
      if (!credential) {
        toast.error('Member is not registered with access control system');
        return false;
      }

      const result = await hikvisionService.configureAccess(
        credential.person_id,
        deviceSerialNo,
        doorList,
        validStartTime,
        validEndTime,
        branchId
      );

      if (!result.success) {
        throw new Error(result.error);
      }

      toast.success('Access permissions granted successfully');
      return true;
    } catch (error) {
      console.error('Error granting access permissions:', error);
      toast.error('Failed to grant access permissions');
      return false;
    } finally {
      setIsProcessing(false);
    }
  };

  const revokeAccess = async (memberId: string, branchId: string, deviceSerialNo: string): Promise<boolean> => {
    setIsProcessing(true);
    try {
      const credential = await getMemberCredential(memberId);
      if (!credential) return true; // No credentials to revoke

      // Delete access privileges via proxy
      const { data: deleteResponse, error: deleteError } = await supabase.functions.invoke('hikvision-proxy', {
        body: {
          branchId,
          endpoint: '/api/hpcgw/v1/acs/privilege/delete',
          method: 'POST',
          data: {
            personId: credential.person_id,
            deviceSerialNo: deviceSerialNo
          }
        }
      });

      if (deleteError || !deleteResponse?.success) {
        console.warn('Failed to delete privileges from Hikvision:', deleteResponse?.error);
      }
      
      // Update local database
      await supabase
        .from('hikvision_access_privileges')
        .update({ 
          status: 'inactive',
          updated_at: new Date().toISOString()
        })
        .eq('person_id', credential.person_id)
        .ilike('door_id', `${deviceSerialNo}%`);

      toast.success('Access permissions revoked successfully');
      return true;
    } catch (error) {
      console.error('Error revoking access permissions:', error);
      toast.error('Failed to revoke access permissions');
      return false;
    } finally {
      setIsProcessing(false);
    }
  };

  const processAttendanceEvents = async (branchId: string): Promise<boolean> => {
    try {
      setIsProcessing(true);
      
      const result = await hikvisionService.processEvents(branchId);
      
      if (result.success) {
        toast.success(`Processed ${result.data?.processedCount || 0} attendance events`);
        return true;
      } else {
        throw new Error(result.error);
      }
    } catch (error) {
      console.error('Error processing attendance events:', error);
      toast.error('Failed to process attendance events');
      return false;
    } finally {
      setIsProcessing(false);
    }
  };

  const fetchLatestEvents = async (branchId: string): Promise<boolean> => {
    try {
      setIsProcessing(true);
      
      const result = await hikvisionService.fetchEvents(branchId);
      
      if (result.success) {
        toast.success(`Fetched ${result.data?.fetched || 0} new events`);
        return true;
      } else {
        throw new Error(result.error);
      }
    } catch (error) {
      console.error('Error fetching events:', error);
      toast.error('Failed to fetch latest events');
      return false;
    } finally {
      setIsProcessing(false);
    }
  };

  return {
    registerMember,
    unregisterMember,
    grantAccess,
    revokeAccess,
    processAttendanceEvents,
    fetchLatestEvents,
    isProcessing
  };
};
